Executor Framework
---------------------

public interface Executor {
	void execute(Runnable command)
}

public interface ExecutorService extends Executor {
	void shutdown()
	List<Runnable> shutdownNow()
	boolean isShutdown() // if this executor has been shut down. This method returns true if you have called the shutdown()
							method of the executor 

	boolean isTerminated() // if all tasks have completed following shut down (if you have called the shutdown() or
							  shutdownNow() methods and the executor finishes the process of shutting it down.)
	awaitTermination(long timeout, TimeUnit unit) // awaitTermination(long timeout, TimeUnit unit): This method blocks
													the calling thread until the tasks of the executor have ended or the timeout occurs.
													The TimeUnit class is an enumeration with the following constants: DAYS, HOURS,
													MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS, and SECONDS

	submit(Callable<T> task)
	submit(Runnable task)
}

ThreadPoolExecutor - 
	
	getPoolSize()
	
	getActiveCount()
	
	getCompletedTaskCount()
	
	shutdown():	
		Critical aspect of the ThreadPoolExecutor class, and of the executors in general,
		is that you have to end it explicitly. If you don't do this, the executor will continue its execution
		and the program won't end. If the executor doesn't have tasks to execute, it continues waiting
		for new tasks and it doesn't end its execution.

		After you call the shutdown() method, if you try to send another task to the executor, 
		it will be rejected and the executor will throw a RejectedExecutionException exception.

	shutdownNow(): This method shut downs the executor immediately. It doesn't
					execute the pending tasks. It returns a list with all these pending tasks. The tasks
					that are running when you call this method continue with their execution, but the
					method doesn't wait for their finalization.

class Executors construct executors and other related objects.
	newCachedThreadPool() 
			// a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are
			//available These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.
			// If no existing thread is available, a new thread will be created and added to the pool.
			
	newFixedThreadPool(int nThreads) 
			// Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.
			// If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available.
			// If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.
	
	newScheduledThreadPool(int corePoolSize) 
		//Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
	
	newSingleThreadScheduledExecutor() 
		// single-threaded executor that can schedule commands to run after a given delay, or to execute periodically

Thread Executor methods (additional):

invokeAny() method of the ThreadPoolExecutor class receives a list of tasks, launches them, and returns the result
			of the first task that finishes without throwing an exception.

invokeAll() method receives a list of the Callable objects and returns a list of the Future objects. This list will have a Future
			object per task in the list. The first object in the list of the Future objects will be the object that controls the 
			first task in the list of the Callable objects, and so on

ScheduledThreadPoolExecutor
-------------------------------------------

public interface ScheduledFuture

To execute a task in this scheduled executor after a period of time, you have to use the
schedule() method.

ScheduledFuture<?> result=executor.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS);

public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period,  TimeUnit unit);

Cancelling task execution:

Future:
boolean cancel(boolean mayInterruptIfRunning);

Depending on the parameter of the cancel() method and the status of the task, the behavior of this method is different:

If the task is waiting in the executor to get a Thread object that will execute it,
the task is canceled and never begins its execution. If the task is already running,
it depends on the parameter of the method. The cancel() method receives a
Boolean value as a parameter. If the value of that parameter is true and the task
is running, it will be canceled. If the value of the parameter is false and the task is
running, it won't be canceled.

If you use the get() method of a Future object that controls a task that has been canceled,
the get() method will throw a CancellationException exception.


class FutureTask<V> implements RunnableFuture<V>
------------------------------------------------------
A cancellable asynchronous computation.  This class provides a base implementation of {@link Future},
with methods to start and cancel a computation

The FutureTask class provides a method called done() that allows you to execute some code after the finalization
of a task executed in an executor. It can be used to make som post-process operations, generating a report,
sending results by e-mail, or releasing some resources.

This method is called internally by the FutureTask class when the execution of
the task that this FutureTask object is controlling finishes. The method is called after the
result of the task is set and its status is changed to the isDone status, regardless of whether
the task has been canceled or finished normally.

By default, this method is empty. You can override the FutureTask class and implement this
method to change this behavior. In this recipe, you will learn how to override this method to
execute code after the finalization of the tasks.

FutureTask
-------------------
provides a method called done() that allows to execute some code after the finalization of a task executed in an executor
It can be used to make some post-process operations,
This method is called internally by the FutureTask class when the execution of
the task that this FutureTask object is controlling finishes

The method is called after the
result of the task is set and its status is changed to the isDone status, regardless of whether
the task has been canceled or finished normally.