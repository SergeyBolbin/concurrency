Java Monitor Pattern (intristic lock):

 @ThreadSafe
 public class PersonSet {
     @GuardedBy("this")
     private final Set<Person> mySet = new HashSet<Person>();

     public synchronized void addPerson(Person p) {
         mySet.add(p);
     }

     public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
     }
 }


Private Lock :

 public class PrivateLock {
     private final Object myLock = new Object();

     @GuardedBy("myLock") Widget widget;
     void someMethod() {
         synchronized(myLock) {
            // Access or modify the state of widget
         }
     }
 }


Delegating Thread Safety:

    If a class is composed of multiple independent thread-safe state variables and has no operations that have any invalid
    state transitions, then it can delegate thread safety to the underlying state variables.

    @ThreadSafe
    public class DelegatingVehicleTracker {
        private final ConcurrentMap<String, Point> locations;
        private final Map<String, Point> unmodifiableMap;

        public DelegatingVehicleTracker(Map<String, Point> points) {
            locations = new ConcurrentHashMap<String, Point>(points);
            unmodifiableMap = Collections.unmodifiableMap(locations);
        }

        public Map<String, Point> getLocations() {
            return unmodifiableMap;
        }

        public Point getLocation(String id) {
            return locations.get(id);
        }

        public void setLocation(String id, int x, int y) {
            if (locations.replace(id, new Point(x, y)) == null)
                throw new IllegalArgumentException("invalid vehicle name: " + id);
        }
    }


Example:
    @NotThreadSafe
    public class ListHelper<E> {
        public List<E> list = Collections.synchronizedList(new ArrayList<E>());
        ...
        public synchronized boolean putIfAbsent(E x) {
            boolean absent = !list.contains(x);
            if (absent)
                list.add(x);
            return absent;
        }
    }

The  problem  is  that  it  synchronizes  on  the
wrong  lock.  Whatever  lock  the  List  uses  to  guard  its  state,  it  sure  isn't  the  lock  on  the  ListHelper.
ListHelper provides  only  the  illusion  of  synchronization;  the  various  list operations,  while  all synchronized,
 use  different  locks,
which means that putIfAbsent  is not atomic relative to other operations on the List. So there  is no guarantee that
another thread won't modify the list while putIfAbsent is executing


    @ThreadSafe
    public class ListHelper<E> {
        public List<E> list = Collections.synchronizedList(new ArrayList<E>());
        ...
        public boolean putIfAbsent(E x) {
            synchronized (list) {
                boolean absent = !list.contains(x);
                if (absent)
                    list.add(x);
                return absent;
            }
        }
    }