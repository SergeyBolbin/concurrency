N-B Algorithms:
--------------------------------------

use low-level atomic machine instructions such as compareand-swap instead of locks to ensure data integrity under concurrent access

Locking disadvantages:
    Suspending and resuming a thread has a lot of overhead and generally entails a lengthy interruption
    When a thread is waiting for a lock, it cannot do anything else
    (a serious problem if the blocked thread is a high-priority
     thread but the thread holding the lock is a lower-priority thread = priority inversion)

Volatile disadvantages:
    Volatile variables are a lighter-weight synchronization mechanism than locking because they do not involve context switches or thread scheduling
    However, volatile variables have some limitations compared to locking:
    while they provide similar visibility guarantees, they cannot be used to construct atomic compound actions.
    they cannot be used to reliably implement common tools such as counters or mutexes
    In order to not lose an update, the entire read-modify-write operation must be atomic

Hardware support for concurrency
------------------------------------------
Exclusive locking - pessimistic approach

Optimistic approach:
collision detection to determine if there has been interference from other parties during the update,
in which case the operation fails and can be retried

Early processors atomic operations (for impl. mutexes): test-and-set, fetch-and-increment, or swap
Modern read-modify-write instructions: compare-and-swap or load-linked/store-conditional

Sparc, IA32: CAS
PowerPC: load-linked + store-conditional

Compare and swap
--------------------
operands:
V - memory location
B - old value expected
A - new value to set

Atomically update V by value of B if the current value of V matches to the expected value A
otherwise does nothing
In either case, it returns the value currently in V.

The typical pattern for using CAS is first to read the value A from V, derive
the new value B from A, and then use CAS to atomically change V from A to
B so long as no other thread has changed V to another value in the meantime.
CAS addresses the problem of implementing atomic read-modify-write sequences
without locking, because it can detect interference from other threads.

CAS is an optimistic technique—it proceeds with the update in the hope of success
When multiple threads attempt to update the same variable simultaneously using CAS,
one wins and updates the variable’s value, and the rest lose

Because a thread that loses a CAS is not blocked, it can decide
whether it wants to try again, take some other recovery action, or do nothing

The primary disadvantage of CAS is that it forces the caller to
deal with contention (by retrying, backing off, or giving up), whereas locks deal
with contention automatically by blocking until the lock is available


Atomics
-------------------

Atomic variables are finer-grained and lighter-weight than locks,
are critical for implementing high-performance concurrent code on multiprocessor systems

The fast (uncontended) path for updating an atomic variable is no slower than the fast path for acquiring a lock, and usually faster;
the slow path is definitely faster than the slow path for locks because it does not involve suspending and rescheduling threads.

The atomic variable classes provide a generalization of volatile variables to support atomic conditional read-modify-write operations
AtomicXXX provides get and set methods with the same memory semantics as reads and writes to a volatile XXX
also contans compareAndSet(XXX expect, XXX update) methods

There are twelve atomic variable classes, divided into four groups:
    - scalars,
    - field updaters,
    - arrays, and
    - compound variables

Scalars: AtomicInteger, AtomicLong, AtomicBoolean, and AtomicReference. All support CAS;

The atomic array classes (available in Integer, Long, and Reference versions) are arrays whose elements can be updated atomically
The volatile array has volatile semantics only for the array reference, not for its elements.
The primitive wrapper classes are immutable whereas the atomic variable classes are mutable
also do not redefine hashCode or equals; each instance is distinct