Executor Framework
---------------------

public interface Executor {
	void execute(Runnable command)
}

public interface ExecutorService extends Executor {
	void shutdown()
	List<Runnable> shutdownNow()
	boolean isShutdown() // if this executor has been shut down. This method returns true if you have called the shutdown()
							method of the executor 

	boolean isTerminated() // if all tasks have completed following shut down (if you have called the shutdown() or
							  shutdownNow() methods and the executor finishes the process of shutting it down.)
	awaitTermination(long timeout, TimeUnit unit) // awaitTermination(long timeout, TimeUnit unit): This method blocks
													the calling thread until the tasks of the executor have ended or the timeout occurs.
													The TimeUnit class is an enumeration with the following constants: DAYS, HOURS,
													MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS, and SECONDS

	submit(Callable<T> task)
	submit(Runnable task)
}

ThreadPoolExecutor - 
	
	getPoolSize()
	
	getActiveCount()
	
	getCompletedTaskCount()
	
	shutdown():	
		Critical aspect of the ThreadPoolExecutor class, and of the executors in general,
		is that you have to end it explicitly. If you don't do this, the executor will continue its execution
		and the program won't end. If the executor doesn't have tasks to execute, it continues waiting
		for new tasks and it doesn't end its execution.

		After you call the shutdown() method, if you try to send another task to the executor, 
		it will be rejected and the executor will throw a RejectedExecutionException exception.

	shutdownNow(): This method shut downs the executor immediately. It doesn't
					execute the pending tasks. It returns a list with all these pending tasks. The tasks
					that are running when you call this method continue with their execution, but the
					method doesn't wait for their finalization.

class Executors construct executors and other related objects.
	newCachedThreadPool() 
			// a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are
			//available These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.
			// If no existing thread is available, a new thread will be created and added to the pool.
			
	newFixedThreadPool(int nThreads) 
			// Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.
			// If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available.
			// If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.
	
	newScheduledThreadPool(int corePoolSize) 
		//Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
	
	newSingleThreadScheduledExecutor() 
		// single-threaded executor that can schedule commands to run after a given delay, or to execute periodically

Thread Executor methods (additional):

invokeAny() method of the ThreadPoolExecutor class receives a list of tasks, launches them, and returns the result
			of the first task that finishes without throwing an exception.

invokeAll() method receives a list of the Callable objects and returns a list of the Future objects. This list will have a Future
			object per task in the list. The first object in the list of the Future objects will be the object that controls the 
			first task in the list of the Callable objects, and so on

ScheduledThreadPoolExecutor
-------------------------------------------

public interface ScheduledFuture

To execute a task in this scheduled executor after a period of time, you have to use the
schedule() method.

ScheduledFuture<?> result=executor.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS);

public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period,  TimeUnit unit);

Cancelling task execution:

Future:
boolean cancel(boolean mayInterruptIfRunning);

Depending on the parameter of the cancel() method and the status of the task, the behavior of this method is different:

If the task is waiting in the executor to get a Thread object that will execute it,
the task is canceled and never begins its execution. If the task is already running,
it depends on the parameter of the method. The cancel() method receives a
Boolean value as a parameter. If the value of that parameter is true and the task
is running, it will be canceled. If the value of the parameter is false and the task is
running, it won't be canceled.

If you use the get() method of a Future object that controls a task that has been canceled,
the get() method will throw a CancellationException exception.


class FutureTask<V> implements RunnableFuture<V>
------------------------------------------------------
A cancellable asynchronous computation.  This class provides a base implementation of {@link Future},
with methods to start and cancel a computation

The FutureTask class provides a method called done() that allows you to execute some code after the finalization
of a task executed in an executor. It can be used to make som post-process operations, generating a report,
sending results by e-mail, or releasing some resources.

This method is called internally by the FutureTask class when the execution of
the task that this FutureTask object is controlling finishes. The method is called after the
result of the task is set and its status is changed to the isDone status, regardless of whether
the task has been canceled or finished normally.

By default, this method is empty. You can override the FutureTask class and implement this
method to change this behavior.

CompletionService
-------------------
has a method to send the tasks to an executor and a
method to get the Future object for the next task that has finished its execution. Internally,
it uses an Executor object to execute the tasks. This behavior has the advantage to share
a CompletionService object, and sends tasks to the executor so the others can process
the results. The limitation is that the second object can only get the Future objects for those
tasks that have finished its execution, so these Future objects can only be used to get the
results of the tasks.

To execute a task using the completion service, you use the submit() method

When one of these tasks is executed when the completion service finishes its execution, the
completion service stores the Future object used to control its execution in a queue. The
poll() method accesses this queue to see if there is any task that has finished its execution
and, if so, returns the first element of that queue which is a Future object for a task that has
finished its execution. When the poll() method returns a Future object, it deletes it from
the queue. In this case, you have passed two attributes to that method to indicate the time
you want to wait for the finalization of a task, in case the queue with the results of the finished
tasks is empty.

This class also provides two other methods to obtain the Future objects of the finished
tasks. These methods are as follows:

-  poll(): The version of the poll() method without arguments checks if there are
any Future objects in the queue. If the queue is empty, it returns null immediately.
Otherwise, it returns its first element and removes it from the queue.

-  take(): This method, without arguments, checks if there are any Future objects in
the queue. If it is empty, it blocks the thread until the queue has an element. When
the queue has elements, it returns and deletes its first element from the queue.


RejectedExecutionHandler.
----------------------------------

When you want to finish the execution of an executor, you use the shutdown() method
to indicate that it should finish. The executor waits for the completion of the tasks that are
running or waiting for their execution, and then finishes its execution.

If you send a task to an executor between the shutdown() method and the end of its
execution, the task is rejected (RejectedExecutionException thrown), because the executor no longer accepts new tasks.
The ThreadPoolExecutor class provides a mechanism, which is called when a task is rejected:

threadPoolExecutor.setRejectedExecutionHandler(new CustomRejectedHandler())