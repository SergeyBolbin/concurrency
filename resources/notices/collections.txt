Java provides two kinds of collections to use in concurrent applications:

Blocking collections:
    If the operation can't be made immediately, because the collection is full or
    empty, the thread that makes the call will be blocked until the operation can
    be made.

Non-blocking collections:
    If the operation can't be made immediately, the operation returns a
    null value or throws an exception, but the thread that makes the call won't
    be blocked.

    ConcurrentLinkedDeque


Synchronized collections
------------------------------------

    - Vector
    - Hashtable
    - Collections.synchronizedXXX

These classes achieve thread safety by encapsulating their state and synchronizing every public method so that only one
thread at a time can access the collection state.

Vector confusion example:

    Th1 // ArrayOutOfBounds... may be thrown if th2 executed before

    public static Object getLast(Vector list) {
    int lastIndex = list.size() - 1;
    return list.get(lastIndex);
    }


    Th2
    public static void deleteLast(Vector list) {
    int lastIndex = list.size() - 1;
    list.remove(lastIndex);
    }

Fail-fast iterators
------------------------------------------------------------------------------------

The iteration idiom relies on a leap of faith that other threads will not modify the Vector between the calls to size and
get.
When  other  threads  may  concurrently  modify  the  Vector  it  can  lead  to  trouble.
Just  as  with  getLast,  if  another  thread  deletes  an  element  while  you  are  iterating  through  the  Vector
and  the  operations  are  interleaved  unluckily,  this  iteration  idiom  throws ArrayIndexOutOfBoundsException.

    //need to be externally synchronized
    for (int i = 0; i < vector.size(); i++)
        doSomething(vector.get(i));

The iterators returned by the synchronized collections - fail-fast
if they detect that the collection has changed since iteration began, they throw the
unchecked ConcurrentModificationException

if the modification count changes during iteration, hasNext or next 
throws ConcurrentModificationException. However, this check is done without synchronization, so there is a risk of 
seeing a stale value of the modification count and therefore that the iterator does not realize a modification has been 
made
There are several reasons, however, why locking a  collection during iteration may be undesirable:

Other threads that need to access the collection will block until the iteration is complete;
    If the collection is locked is being called with a lock held, which is a risk factor for deadlock
    Starvation or deadlock risk: locking collections for significant periods of time hurts application scalability.
    The longer a lock is held, the  more likely it is to be contended, and if many  threads are blocked waiting for a lock throughput and CPU utilization can
    suffer.

An alternative to locking the collection during iteration is to clone the collection and iterate the copy instead. Since the
clone  is  thread-confined,  no  other  thread  can  modify  it  during  iteration,  eliminating  the  possibility  of
ConcurrentModificationException.

Concurrent collections
-----------------------------------------

ConcurrentHashMap
CopyOnWriteArrayList
Queue -> BlockingQueue

ConcurrentSkipListMap concurrent replacement for sync SortedMap
ConcurrentSkipListSet concurrent replacement for sync SortedSet

ConcurrentHashMap
-----------------
ConcurrentHashMap is a hash-based Map

    - uses Lock striping instead of sync every method on common lock
    - readers can access map concurrently with writers
    - a limited number of writers can modify map concurrently
    - little perf penalty for single-th access
    - weakly-consistent iterators (instead of fail-fast, do not throw ConcurrentModificationException)

        A weakly consistent iterator can tolerate concurrent modification, traverses elements as they existed when the iterator
        was constructed, and may (but is not guaranteed to) reflect modifications to the collection after the construction of the
        iterator.

    - size is allwoed to return approx. value instead of exact count
    - concurrent collections should be expected to change their contents continuously
    - if application  needs  to  lock  the  map  for  exclusive  access  ConcurrentHashMap  is not  an  appropriate